#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>
#include <fcntl.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <errno.h>

#define MAXBUF 1024
#define CHIFFREMENT 1
#define DECHIFFREMENT 0
#define TAILLECHAR 10
#define TAILLEINT 3
#define NBRCONSIGNE 1000
#define TAILLE_MOT_MAX 25

/***********************************STRUCTURE***************************************/
struct consigne{
	int pas;
	int sens;
	char nomFichier[20];
};
typedef struct consigne CONSIGNE;

struct tableau {
	int tabInt[TAILLEINT];
	int nbrligne;
	CONSIGNE consig[NBRCONSIGNE];
};
typedef struct tableau TABLEAU;

struct mot{
	int deb; int fin; int flag; char mot[TAILLE_MOT_MAX];
	int sens; int pas;
	pthread_mutex_t *mut;
};
typedef struct mot MOT;

//********************************INITIALISER*************************************/

TABLEAU init_consigne(TABLEAU t){
	int i, j;
	t.nbrligne = 0;
	for(i=0; i<NBRCONSIGNE; i++){
		t.consig[i].pas = -1;
		t.consig[i].sens = -1;
		for(j=0; j<20; j++){
			t.consig[i].nomFichier[j] = '\0';
		}
	}
	return t;
}

TABLEAU init_tableau(TABLEAU t){
	int i;
	for (i = 0; i < TAILLEINT; i++) {
		t.tabInt[i] = -1;
	}
	return t;
}

MOT init_mot(MOT m){
	int n;
	m.deb=-1;
	m.fin=-1;
	m.flag=0;
	m.sens=-1;
	m.pas=0;
	for(n=0; n<TAILLE_MOT_MAX; n++){
		m.mot[n]='\0';
	}

	return m;
}

/**********************FONCTION*DE*CONVERTION**********************/

int tab_to_int(TABLEAU t){
	if(t.tabInt[2] == -1 && t.tabInt[1] == -1) {
		return t.tabInt[0];
	}

	if (t.tabInt[2] == -1) {
		return (t.tabInt[0] * 10 + t.tabInt[1]);
	}

	if (t.tabInt[2] != -1) {
		return (t.tabInt[0] * 100 + t.tabInt[1] * 10 + t.tabInt[2]);
	}
	return -1;//if erreur
}

int est_caractere_special(int c){
	if(	c != 'a' && c != 'b' && c != 'c' && c != 'd' && c != 'e' && c != 'f' && c != 'g' &&
		c != 'h' && c != 'i' && c != 'j' && c != 'k' && c != 'l' && c != 'm' &&
		c != 'n' && c != 'o' && c != 'p' && c != 'q' && c != 'r' &&	c != 's' && c != 't' &&
		c != 'u' && c != 'v' && c != 'w' && c != 'x' && c != 'y' && c != 'z' &&
		c != 'A' && c != 'B' && c != 'C' && c != 'D' && c != 'E' && c != 'F' && c != 'G' &&
		c != 'H' && c != 'I' && c != 'J' && c != 'K' && c != 'L' && c != 'M' &&
		c != 'N' && c != 'O' && c != 'P' && c != 'Q' && c != 'R' &&	c != 'S' && c != 'T' &&
		c != 'U' && c != 'V' && c != 'W' && c != 'X' && c != 'Y' && c != 'Z' ){
		return 1;
	}
	return 0;
}

int modifier_char(int c, int valeur_modif, int sens){ //sens defini si on chiffre (1) ou on dechiffre (0)
	if( c != EOF ){
		if( est_caractere_special(c) ){
			return c;
		}
		else if(sens == 0){
			sens = -1;
		}
		c = (c + sens*valeur_modif) % 127;
		if( ( c > 90 && c <97 ) || c > 122){
			c = c - 25;
		}
	}
	return c;
}

/*********************FONCTION*DE*LECTURE************************/
int lire_char(int endroit){
	char c;
	return read(endroit, &c, 1) ?c : EOF;
}

TABLEAU lire_fichier_principal(char* fichier){
	int fic = open(fichier, O_RDONLY);
	int i;
	int j = 0;
	char tmp;
	TABLEAU t = init_tableau(t);
	t = init_consigne(t);


	while(tmp != EOF){//lire jusqu'a la fin du fichier
		tmp = lire_char(fic);
		t = init_tableau(t);
		while(tmp != '\n' && tmp != EOF){ // lire qu'une ligne
			while(tmp != '/'){ // passer la partie "path/"
				tmp = lire_char(fic);
			}
			while(tmp!= ';'){// lire le nom du fichier entre le "/" et le ";"
				tmp = lire_char(fic);
				for(i=0; i<20 && tmp != ';' ; i++){// mettre le caractere lu dans un tableau
					t.consig[j].nomFichier[i] = tmp; // mettre le tableau dans un char pour pouvoir recuperer le nom du fichier
					tmp = lire_char(fic);
				}
			}
			tmp = lire_char(fic);// passer le ";"
			while(tmp != ';'){//lire le pas entre les ";"
				for(i=0; i<10 && tmp != ';'; i++){
					t.tabInt[i] = atoi(&tmp);// mettre le chiffre lu dans un tableau
					tmp = lire_char(fic);
				}
				t.consig[j].pas = tab_to_int(t);// transformer les chiffres mis dans le tableau en un nombre
				
			}			
			tmp = lire_char(fic);// passer le ";"
			if(tmp == 'c'){// si la derniere lettre de la ligne est un "c"
				t.consig[j].sens = CHIFFREMENT;
			}
			if(tmp == 'd'){// si la derniere lettre de la ligne est un "d"
				t.consig[j].sens = DECHIFFREMENT;
			}
			tmp = lire_char(fic);//passer la lettre pour etre sur le "\n" et sortir de la deuxieme boucle
			}
		j++;
		t.nbrligne++;
	}
	close(fic);
	return t;
}

int calculer_nombre_mot(char *nomFichier){
	int fic; char c = EOF;
	int nbrespace = 0;
	fic = open(nomFichier, O_RDONLY);
	do{
		c = lire_char(fic);
		if( c == ' '){
			nbrespace++;
		}
		//printf("%c\n", c);
	}while( c!= EOF);

	close(fic);

	return nbrespace+1;
}

MOT lire_ieme_mot(char *nomFichier, int nieme_mot){
	int fic; 
	int i = 0; 
	char c = EOF;
	int comteur_espace = nieme_mot-1;
	int espace=0;
	int position = 0;
	MOT m=init_mot(m);

	fic = open(nomFichier, O_RDONLY);
	//c=lire_char(fic);

	//recuperer n-ieme mot que l'on veut
	if(nieme_mot < calculer_nombre_mot(nomFichier)+1 ){
		do{
			c=lire_char(fic); 
			if(c==' '){
				espace++;
			}
			position++;
		}while(espace!=comteur_espace);

		if(nieme_mot!=1){
			c=lire_char(fic);
			//position--;
		}

		if(nieme_mot==1){
			position--;
		}

		
		m.deb = position;

		do{
			m.mot[i] = c;
			c = lire_char(fic);
			i++;
			position++;
		}while(c != ' ' && c != EOF);
		m.fin = position-1;
	}
	

	close(fic);

	return m;
}

/*************************FONCTION*POUR*PROCESSUS**************************/
pid_t creer_processus(void){
    pid_t pid;

    do {
    	pid = fork();
	}while ((pid == -1) && (errno == EAGAIN));

	return pid;
}

void child_process(char *fichier, int pas, int sens){
	int fic1;
	int ncar = 0;
	int i = 0;
	char buf[MAXBUF];
	char *p;
	//char modifi[] ="_cypher.txt";

	fic1 = open(fichier, O_RDONLY); // ouvre le fichier en mode lecture

	if(fic1 == -1){
		printf("erreur ouverture %s\n", fichier);
		exit(EXIT_FAILURE);
	}

	ncar = read (fic1, buf, MAXBUF); // renvoie le nombre de caractere
									//met dans buf ce qui est lu
	close(fic1);

	while(fichier[i] != '.') i++;
	fichier[i] = '_';
	fichier[i+1] = 'c';
	fichier[i+2] = 'y';
	fichier[i+3] = 'p';
	fichier[i+4] = 'h';
	fichier[i+5] = 'e';
	fichier[i+6] = 'r';
	fichier[i+7] = '.';
	fichier[i+8] = 't';
	fichier[i+9] = 'x';
	fichier[i+10] = 't';
	//Oui, on se fait chier

	fic1 = open(fichier, O_CREAT | O_WRONLY, 0666); // ouvre le fichier en mode ecriture en supprimant ce qu'il y avait dedans

	if(fic1 == -1){
		printf("erreur ouverture %s\n", fichier);
		exit(EXIT_FAILURE);
	}
	//MODIFIER POUR APPELER LES THREADS

	for(i=0; i<ncar; i++){
		buf[i] = modifier_char(buf[i], pas, sens); // modifie les caracteres lu en fonction du pas et du sens
	}

	p = buf; // met ce qui est lu dans p

	printf("ca marche, %s\n", p);

	write(fic1, p, ncar); // ecrit le message final dans le fichier

	for(i=0; i<MAXBUF; i++){
		buf[i]='\0';
	}

	close(fic1);
}

/***********************FONCTION*POUR*THREADS*************************/
void *modifier_mot(void *a) {
	
	int i;
	printf("ok");
	MOT *m=(MOT*)a;
	printf("m : %s\n", m->mot);
	for( i=m->deb; i<= ((m->fin-m->deb)+1) ; i++ ){
		pthread_mutex_lock(m->mut);
		if(m->flag==0){
			m->mot[i] = modifier_char(m->mot[i], m->pas, m->sens);
			m->flag++;
		}
		pthread_mutex_unlock(m->mut);
		
	}return NULL;
}

MOT ajout_struct_pas_sens(TABLEAU t, int indice_consigne){
	MOT m;
	m = init_mot(m);
	m.pas = t.consig[indice_consigne].pas;
	m.sens = t.consig[indice_consigne].sens;
	return m;
}

MOT employee (MOT m){
	pthread_mutex_t mu = PTHREAD_MUTEX_INITIALIZER;
	pthread_t*tid = malloc(sizeof(pthread_t));
	MOT *m2 = malloc(sizeof(MOT));
	int i;

	m2->mut = &mu;
	m2->deb = m.deb;
	m2->fin = m.fin;
	m2->flag = m.flag;
	m2->sens = m.sens;
	m2->pas = m.pas;

	for(i=0; i<TAILLE_MOT_MAX; i++){
		m2->mot[i] = m.mot[i];
	}

	pthread_create(tid, NULL, &modifier_mot, &m2);
	printf("m2 : %s\n", m2->mot);

	for(i=0; i<TAILLE_MOT_MAX; i++){
		m.mot[i] = m2->mot[i];
	}

	free(m2);
	free(tid);

	return m;
}

/************************MAIN************************/
int main(int argc, char* argv[]){
	/*
	char *p = "Donner le nom du fichier en entree svp.\n";
	if(argc == 2){
		char *fichier = argv[1];
	
		TABLEAU t = init_tableau(t);
		t = lire_fichier_principal(fichier);

		pid_t pid;
	    int return_value, i;
	    //int npid;

		for(i=0; i<t.nbrligne; i++){
			pid = creer_processus();
			if(pid == -1){
				printf("fork error\n");
				exit(0);
			}
			else if(pid == 0){
				if(t.consig[i].sens != -1 && t.consig[i].pas != -1 && t.consig[i].nomFichier != NULL){
					child_process(t.consig[i].nomFichier, t.consig[i].pas, t.consig[i].sens);
					break;
				}
			}
			else{
				pid = wait(&return_value);
				//i++;
			}
		}
		return 0;
	}
	else write(1, p, 40);*/
	
	MOT m;

	m = lire_ieme_mot("msg1.txt", 1);
	printf("%s\n", m.mot);
	m = employee(m);
	printf("%s\n", m.mot);

	return 0;
}