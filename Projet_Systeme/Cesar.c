#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>
#include <fcntl.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <errno.h>

#define MAXBUF 1024
#define CHIFFREMENT 1
#define DECHIFFREMENT 0
#define TAILLECHAR 10
#define TAILLEINT 3
#define NBRCONSIGNE 2000
#define TAILLE_MOT_MAX 25

/***********************************STRUCTURE***************************************/
struct consigne{
	int pas;// le pas du chiffrement
	int sens;// le sens du chiffrement
	char nomFichier[20];// le nom du fichier ou se trouve le texte a modifer
};
typedef struct consigne CONSIGNE;

struct tableau {
	int tabInt[TAILLEINT];
	int nbrligne;// le nomre de ligne du fichier principal donc le nombre de consigne
	CONSIGNE consig[NBRCONSIGNE];// un tableau de consigne pour stocker une consigne par ligne
};
typedef struct tableau TABLEAU;

struct mot{
	int flag;// si le mot a ete modifie ou non
	char mot[TAILLE_MOT_MAX];// le mot stock√©
	int sens; int pas;// le pas et le sens du chiffrement
	pthread_mutex_t *mut;// le mutex
};
typedef struct mot MOT;

//********************************INITIALISER*************************************/

TABLEAU initialiser_consigne(TABLEAU t){
	int i, j;
	t.nbrligne = 0;
	for(i = 0; i<NBRCONSIGNE; i++){
		t.consig[i].pas = -1;
		t.consig[i].sens = -1;
		for(j = 0; j < 20; j++){
			t.consig[i].nomFichier[j] = '\0';
		}
	}
	return t;
}

TABLEAU initialiser_tableau(TABLEAU t){
	int i;
	for (i = 0; i < TAILLEINT; i++) {
		t.tabInt[i] = -1;
	}
	return t;
}

MOT initialiser_mot(MOT m){
	int n;
	m.flag = 0;
	for(n = 0; n < TAILLE_MOT_MAX; n++){
		m.mot[n] = '\0';
	}

	return m;
}

/**********************FONCTION*DE*CONVERTION**********************/

int tab_to_int(TABLEAU t){// permet de transformer un tableau contenant un entier par case en un nombre
	if(t.tabInt[2] == -1 && t.tabInt[1] == -1) {
		return t.tabInt[0];
	}

	if (t.tabInt[2] == -1) {
		return (t.tabInt[0] * 10 + t.tabInt[1]);
	}

	if (t.tabInt[2] != -1) {
		return (t.tabInt[0] * 100 + t.tabInt[1] * 10 + t.tabInt[2]);
	}
	return -1;//if erreur
}

int modifier_char(int c, int cle, int sens){// fonction pour modifier un caractere

	if(sens == DECHIFFREMENT){
		if(c >= 97 && c <=122)
			c =(((c -'a')+cle)%26)+'a';
		if(c >= 65 && c <=90)
			c =(((c -'A')+cle)%26)+'A';
	}else if(sens == CHIFFREMENT){
		if(c >= 97 && c <=122)
			c =((((c +26)-'a')+cle)%26)+'a';
		if(c >= 65 && c <=90)
			c =((((c +26)-'A')+cle)%26)+'A';
	}

	return c;
}

/*********************FONCTION*DE*LECTURE************************/
int lire_char(int endroit){// lit un caractere et le retourne
	char c;
	return read(endroit, &c, 1) ?c : EOF;
}

TABLEAU lire_fichier_principal(char* fichier){// lit le fichier principal et determine les consignes
	int fic = open(fichier, O_RDONLY);// ouvre le fichier principal en mode lecture
	int i;
	char tmp;// char pour stocker le caractere lu

	TABLEAU t = initialiser_tableau(t);
	t = initialiser_consigne(t);


	while(tmp != EOF){//lire jusqu'a la fin du fichier
		tmp = lire_char(fic);
		t = initialiser_tableau(t);
		while(tmp != '\n' && tmp != EOF){// lire qu'une ligne
			while(tmp != '/'){// passer la partie "path/"
				tmp = lire_char(fic);
			}
			while(tmp!= ';'){// lire le nom du fichier entre le "/" et le ";"
				tmp = lire_char(fic);
				for(i = 0; i < 20 && tmp != ';' ; i++){// mettre le caractere lu dans un tableau
					t.consig[t.nbrligne].nomFichier[i] = tmp;// mettre le tableau dans un char pour pouvoir recuperer le nom du fichier
					tmp = lire_char(fic);
				}
			}
			tmp = lire_char(fic);// passer le ";"
			while(tmp != ';'){//lire le pas entre les ";"
				for(i = 0; i < 10 && tmp != ';'; i++){
					t.tabInt[i] = atoi(&tmp);// mettre le chiffre lu dans un tableau
					tmp = lire_char(fic);
				}
				t.consig[t.nbrligne].pas = tab_to_int(t);// transformer les chiffres mis dans le tableau en un nombre				
			}			
			tmp = lire_char(fic);// passer le ";"
			if(tmp == 'c'){// si la derniere lettre de la ligne est un "c"
				t.consig[t.nbrligne].sens = CHIFFREMENT;
			}
			if(tmp == 'd'){// si la derniere lettre de la ligne est un "d"
				t.consig[t.nbrligne].sens = DECHIFFREMENT;
			}
			tmp = lire_char(fic);//passer la lettre pour etre sur le "\n" et sortir de la deuxieme boucle
			}
		t.nbrligne++;// si l'on est pas a la fin du fichier on incremente le nombre de ligne
	}
	close(fic);
	return t;
}

int calculer_nombre_mot(char *nomFichier){// calcule le nombre de mot dans un fichier cible
	int fic; char c = EOF;
	int nbrespace = 0;
	fic = open(nomFichier, O_RDONLY);// ouvre le fichier en mode lecture
	do{
		c = lire_char(fic);
		if( c == ' '){
			nbrespace++;// compte le nombre d'espace
		}
		//printf("%c\n", c);
	}while( c!= EOF);

	close(fic);

	return nbrespace+1;// retourne le nombre d'espace+1 pour avoir le nombre de mot
}

MOT lire_ieme_mot(CONSIGNE cons, int nieme_mot){// lit le ieme mot donner en entree
	int fic; 
	int i = 0; 
	char c = EOF;
	int comteur_espace = nieme_mot-1;
	int espace = 0;
	
	MOT m = initialiser_mot(m);
	fic = open(cons.nomFichier, O_RDONLY);// ouvre le fichier en mode lecture seule
	
	//recuperer n-ieme mot que l'on veut
	if(nieme_mot < calculer_nombre_mot(cons.nomFichier)+1 ){// avance dans le mot jusqu'au mot voulu
		do{
			c = lire_char(fic);
			if(c == ' '){
				espace++;
			}
		}while(espace != comteur_espace);
		if(nieme_mot != 1){
			c = lire_char(fic);
		}
		do{
			m.mot[i] = c;
			c = lire_char(fic);

			i++;
			
		}while(c != ' ' && c != EOF);
		m.mot[i] = c;
		
	}
	m.pas = cons.pas;
	m.sens = cons.sens;
	close(fic);

	return m;
}

/***********************FONCTION*POUR*THREADS*************************/
void *modifier_mot(void *word) {
	int i;

	MOT* m = (MOT*) word;
		
	pthread_mutex_lock(m->mut);
	for( i = 0; i <= TAILLE_MOT_MAX && m->mot[i] != '\0'; i++ ){
		m->mot[i] = modifier_char(m->mot[i], m->pas, m->sens);
	}
	pthread_mutex_unlock(m->mut);
	
	return m;
}

MOT fonction_threads(MOT m){
	pthread_mutex_t mu = PTHREAD_MUTEX_INITIALIZER;
	pthread_t tid;
	MOT *m2 = malloc(sizeof(MOT));
	int i;

	m2->mut = &mu; 
	m2->flag = m.flag;
	m2->sens = m.sens;
	m2->pas = m.pas;

	for(i = 0; i < TAILLE_MOT_MAX; i++){
		m2->mot[i] = m.mot[i];
	}

	pthread_create(&tid, NULL, &modifier_mot, m2);

	pthread_join(tid, NULL);

	for(i = 0; i < TAILLE_MOT_MAX; i++){
		m.mot[i] = m2->mot[i];
	}
	
	free(m2);

	return m;
}


/*************************FONCTION*POUR*PROCESSUS**************************/
pid_t creer_processus(void){
    pid_t pid;

    do {
    	pid = fork();
	}while ((pid == -1) && (errno == EAGAIN));

	return pid;
}

char* modifier_nom_fichier(char *fichier){
	int i = 0;
	char *destination = fichier;
	while(fichier[i] != '.')i++;
	destination[i++] = '_';
	destination[i++] = 'c';
	destination[i++] = 'y';
	destination[i++] = 'p';
	destination[i++] = 'h';
	destination[i++] = 'e';
	destination[i++] = 'r';
	destination[i++] = '.';
	destination[i++] = 't';
	destination[i++] = 'x';
	destination[i++] = 't';
	while(i<20){
		destination[i] = '\0';
		i++;
	}

	return destination;
}

int taille_mot(char *mot){
	int i; int tmp = 0;
	for(i = 0; mot[i] != '\0' && mot[i] != EOF; i++){
		tmp ++;
	}
	return tmp;
}

void processus_fils(CONSIGNE cons){
	int fic1;
	int i = 0;
	int return_value;
	char buf[MAXBUF];

	fic1 = open(cons.nomFichier, O_RDONLY); // ouvre le fichier en mode lecture

	if(fic1 == -1){
		printf("erreur ouverture %s\nle fichier n'existe pas\n", cons.nomFichier);
		exit(EXIT_FAILURE);
	}

	read (fic1, buf, MAXBUF); // renvoie le nombre de caractere
									//met dans buf ce qui est lu
	close(fic1);

	int nbr_mot = calculer_nombre_mot(cons.nomFichier);
	
	MOT m[nbr_mot+1];

	for(i = 1; i <= nbr_mot; i++){
		m[i] = lire_ieme_mot(cons, i);
	}

	if(cons.sens == DECHIFFREMENT){
		for(i = 1; i <= nbr_mot; i++){
			m[i] = fonction_threads(m[i]);
			wait(&return_value);
			write(1, m[i].mot, TAILLE_MOT_MAX);
		}
	}
	else
		if(cons.sens == CHIFFREMENT){
		modifier_nom_fichier(cons.nomFichier);
		fic1 = open(cons.nomFichier, O_CREAT | O_WRONLY, 0666); // ouvre le fichier en mode ecriture en le creant si besoin est

		if(fic1 == -1){
			printf("erreur ouverture %s\n", cons.nomFichier);
			exit(EXIT_FAILURE);
		}

		for(i = 1; i <= nbr_mot; i++){
			m[i] = fonction_threads(m[i]);
			wait(&return_value);
			if(m[i].mot[0] != '\0'){
				write(fic1, m[i].mot, taille_mot(m[i].mot));
			}
		}
	}
	
	close(fic1);
}

void fonction_principal(char *fichier){
	TABLEAU t = initialiser_tableau(t);
	t = lire_fichier_principal(fichier);
	pid_t pid;
	int return_value;
    int i;

	for(i = 0; i < t.nbrligne; i++){
		pid = creer_processus();
		if(pid == -1){
			printf("fork error\n");
			exit(0);
		}
		else if(pid == 0){
			if(t.consig[i].sens != -1 && t.consig[i].pas != -1 && t.consig[i].nomFichier != NULL){
				processus_fils(t.consig[i]);
				printf("fait pour %s\n", t.consig[i].nomFichier);
				break;
			}
		}
		else wait(&return_value);
		}
}

/************************MAIN************************/
int main(int argc, char* argv[]){
	
	char *p = "Donner le nom du fichier en entree svp.\n";
	
	if(argc == 2){
		char *fichier = argv[1];
		fonction_principal(fichier);
		
	}
	else write(1, p, 40);
	
	return 0;
}