#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>
#include <fcntl.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <errno.h>

#define MAXBUF 1024
#define CHIFFREMENT 1
#define DECHIFFREMENT 0
#define TAILLECHAR 10
#define TAILLEINT 3
#define NBRCONSIGNE 3

/***********************************STRUCTURE***************************************/
struct consigne{
	int pas;
	int sens;
	char nomFichier[20];
};
typedef struct consigne CONSIGNE;

typedef struct tableau TABLEAU;
struct tableau {
	int tabInt[TAILLEINT];
	CONSIGNE consig[NBRCONSIGNE];
};


//********************************INITIALISER*************************************/

TABLEAU init_consigne(TABLEAU t){
	int i, j;
	for(i=0; i<NBRCONSIGNE; i++){
		t.consig[i].pas = -1;
		t.consig[i].sens = -1;
		for(j=0; j<20; j++){
			t.consig[i].nomFichier[j] = '\0';
		}
	}
	return t;
}

TABLEAU init_tableau(TABLEAU t){
	
	int i;
	for (i = 0; i < TAILLEINT; i++) {
		t.tabInt[i] = -1;
	}
	return t;
}

/**********************FONCTION*DE*CONVERTION**********************/

int tab_to_int(TABLEAU t){
	if(t.tabInt[2] == -1 && t.tabInt[1] == -1) {
		return t.tabInt[0];
	}

	if (t.tabInt[2] == -1) {
		return (t.tabInt[0] * 10 + t.tabInt[1]);
	}

	if (t.tabInt[2] != -1) {
		return (t.tabInt[0] * 100 + t.tabInt[1] * 10 + t.tabInt[2]);
	}
	return -1;//if erreur
}

int est_caractere_special(int c){//fonction a finir pour les caractere speciaux
	if(	c != 'a' && c != 'b' && c != 'c' && c != 'd' && c != 'e' && c != 'f' && c != 'g' &&
		c != 'h' && c != 'i' && c != 'j' && c != 'k' && c != 'l' && c != 'm' &&
		c != 'n' && c != 'o' && c != 'p' && c != 'q' && c != 'r' &&	c != 's' && c != 't' &&
		c != 'u' && c != 'v' && c != 'w' && c != 'x' && c != 'y' && c != 'z' &&
		c != 'A' && c != 'B' && c != 'C' && c != 'D' && c != 'E' && c != 'F' && c != 'G' &&
		c != 'H' && c != 'I' && c != 'J' && c != 'K' && c != 'L' && c != 'M' &&
		c != 'N' && c != 'O' && c != 'P' && c != 'Q' && c != 'R' &&	c != 'S' && c != 'T' &&
		c != 'U' && c != 'V' && c != 'W' && c != 'X' && c != 'Y' && c != 'Z' ){
		return 1;
	}
	return 0;
}

int modifier_char(int c, int valeur_modif, int sens){ //sens defini si on chiffre (1) ou on dechiffre (0)
	if( c != EOF ){
		if( est_caractere_special(c) ){
			return c;
		}
		else if(sens == 0){
			sens = -1;
		}
		c = (c + sens*valeur_modif) % 127;
		if( ( c > 90 && c <97 ) || c > 122){
			c = c - 25;
		}
	}
	return c;
}

/*********************FONCTION*DE*LECTURE************************/
int lire_char(int endroit){
	char c;
	return read(endroit, &c, 1) ?c : EOF;
}

TABLEAU lire_fichier_principal(char* fichier){
	int fic = open(fichier, O_RDONLY);
	int i;
	int j = 0;
	char tmp;
	TABLEAU t = init_tableau(t);
	t = init_consigne(t);


	while(tmp != EOF){//lire jusqu'a la fin du fichier
		tmp = lire_char(fic);
		t = init_tableau(t);
		while(tmp != '\n' && tmp != EOF){ // lire qu'une ligne
			while(tmp != '/'){ // passer la partie "path/"
				tmp = lire_char(fic);
			}
			while(tmp!= ';'){// lire le nom du fichier entre le "/" et le ";"
				tmp = lire_char(fic);
				for(i=0; i<20 && tmp != ';' ; i++){// mettre le caractere lu dans un tableau
					t.consig[j].nomFichier[i] = tmp; // mettre le tableau dans un char pour pouvoir recuperer le nom du fichier
					tmp = lire_char(fic);
				}
			}
			tmp = lire_char(fic);// passer le ";"
			while(tmp != ';'){//lire le pas entre les ";"
				for(i=0; i<10 && tmp != ';'; i++){
					t.tabInt[i] = atoi(&tmp);// mettre le chiffre lu dans un tableau
					tmp = lire_char(fic);
				}
				t.consig[j].pas = tab_to_int(t);// transformer les chiffres mis dans le tableau en un nombre
				
			}			
			tmp = lire_char(fic);// passer le ";"
			if(tmp == 'c'){// si la derniere lettre de la ligne est un "c"
				t.consig[j].sens = CHIFFREMENT;
			}
			if(tmp == 'd'){// si la derniere lettre de la ligne est un "d"
				t.consig[j].sens = DECHIFFREMENT;
			}
			tmp = lire_char(fic);//passer la lettre pour etre sur le "\n" et sortir de la deuxieme boucle
			}
		j++;
	}
	close(fic);
	return t;
}

/*************************FONCTION*POUR*PROCESSUS**************************/
pid_t create_process(void){
    pid_t pid;

    do {
    	pid = fork();
	}while ((pid == -1) && (errno == EAGAIN));

	return pid;
}

void child_process(char *fichier, int pas, int sens){
	int fic1;
	int ncar = 0;
	int i = 0;
	char buf[MAXBUF];
	char *p;
	//char modifi[] ="_cypher.txt";

	fic1 = open(fichier, O_RDONLY); // ouvre le fichier en mode lecture

	if(fic1 == -1){
		printf("erreur ouverture %s\n", fichier);
		exit(EXIT_FAILURE);
	}

	ncar = read (fic1, buf, MAXBUF); // renvoie le nombre de caractere
									//met dans buf ce qui est lu
	close(fic1);

	while(fichier[i] != '.') i++;
	fichier[i] = '_';
	fichier[i+1] = 'c';
	fichier[i+2] = 'y';
	fichier[i+3] = 'p';
	fichier[i+4] = 'h';
	fichier[i+5] = 'e';
	fichier[i+6] = 'r';
	fichier[i+7] = '.';
	fichier[i+8] = 't';
	fichier[i+9] = 'x';
	fichier[i+10] = 't';

	fic1 = open(fichier, O_CREAT | O_WRONLY); // ouvre le fichier en mode ecriture en supprimant ce qu'il y avait dedans

	if(fic1 == -1){
		//printf("erreur ouverture %s\n", fichier);
		//exit(EXIT_FAILURE);
		exit(0);
	}
	for(i=0; i<ncar; i++){
		buf[i] = modifier_char(buf[i], pas, sens); // modifie les caracteres lu en fonction du pas et du sens
	}
	p = buf; // met ce qui est lu dans p
	printf("ca marche\n");
	write(fic1, p, ncar); // ecrit le message final dans le fichier

	close(fic1);
}



/************************MAIN************************/
int main(int argc, char* argv[]){
	char *p = "Donner le nom du fichier en entree svp.\n";

	if(argc == 2){
		char *fichier = argv[1];
	
		TABLEAU t = init_tableau(t);
		t = lire_fichier_principal(fichier);

		pid_t pid;
	    int return_value, i;

		for(i=0; i<NBRCONSIGNE; i++){
			pid = create_process();
			if(pid == -1){
				printf("fork error\n");
				exit(0);
			}
			else if(pid == 0){
				if(t.consig[i].sens != -1 && t.consig[i].pas != -1 && t.consig[i].nomFichier != NULL){
					child_process(t.consig[i].nomFichier, t.consig[i].pas, t.consig[i].sens);
				}
			}
			else{
				pid = wait(&return_value);
			}
		}
		return 0;
	}
	else write(1, p, 40);
	return 0;
}