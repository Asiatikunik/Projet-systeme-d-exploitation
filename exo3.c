#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>

// compiler avec -lpthread a la fin pour que ca marche

//version max en globale
//int res = -1

typedef struct {
	int deb; int fin; int *res; int *tab;
	pthread_mutex_t *mut;
} Tableau;

void *cherche(void *a) {
	
	int i;
	Tableau *t= (Tableau *)a; 
	//le mutex ici sert seulement a proteger si on utilise
	//une variable globale que tous les threads peuvent modifier

	for(i=t->deb;i<t->fin;i++){
		pthread_mutex_lock(t->mut);
		if(*(t->res) < t->tab[i]){
			*(t->res) = t->tab[i];
		}
		pthread_mutex_unlock(t->mut);
	}return NULL;

	/*version avec variable globale
	for(i=t->deb;i<t->fin;i++){
		pthread_mutex_lock(t->mut);
		if(res < t->tab[i]){
			res = t->tab[i];
		}
		pthread_mutex_unlock(t->mut);*/
}

int main(int argc, char ** argv) {
	int res = -1; // valeur maximum
	pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
	
	int n=atoi(argv[1]);

	int *tab=malloc(n*sizeof(int));
	int i;
	
	
	srand(time(NULL));
	pthread_t*tid=malloc(n*sizeof(pthread_t));
	
	for(i=0; i<n; tab[i++]=(rand()%(1000)+1));
	
	Tableau *arg=malloc(atoi(argv[1])*sizeof(Tableau));

	for(i=0; i<n; ++i){
		arg[i].mut=&m;
		arg[i].tab = tab;
		arg[i].res = &res;
		arg[i].deb = (n*i)/n; arg[i].fin=(n*(i+1))/n;
		
		pthread_create(tid+i,NULL,&cherche,arg+i);
	} 

	for(i=0; i<n;++i){
		printf("%d\n", tab[i]);
	}
	
	for(i=0; i<n;++i){
		pthread_join(tid[i],NULL);
	}

	printf("max : %d\n",res);

	free(tab);
	free(arg);
	free(tid);		
	
	return 0;
}